import logging
from typing import TYPE_CHECKING, Set, Tuple, Union

from pip import __file__ as pip_location

if TYPE_CHECKING:
    pass

logger = logging.getLogger(__name__)


def _dedup(a: str, b: str) -> Union[Tuple[str], Tuple[str, str]]:
    return (a, b) if a != b else (a,)


class _Prefix:
    def __init__(self, path: str) -> None:
        self.path = path
        self.setup = False
        site_packages_paths = site.getsitepackages()
        self.bin_dir = os.path.join(site_packages_paths[0], 'bin')
        self.lib_dirs = _dedup(site_packages_paths[0], site_packages_paths[1])


def get_runnable_pip() -> str:
    source = os.path.dirname(os.path.abspath(pip_location))
    if not os.path.isdir(source):
        return source
    return os.path.join(source, "__pip-runner__.py")


def _get_system_sitepackages() -> Set[str]:
    system_sites = site.getsitepackages()
    return {os.path.normcase(path) for path in system_sites}


import os
import site
import textwrap
from collections import OrderedDict
from types import TracebackType
from typing import TYPE_CHECKING, Optional, Set, Tuple, Type, Union

if TYPE_CHECKING:
    pass

logger = logging.getLogger(__name__)


def _dedup(a: str, b: str) -> Union[Tuple[str], Tuple[str, str]]:
    return (a, b) if a != b else (a,)


class _Prefix:
    def __init__(self, path: str) -> None:
        self.path = path
        self.setup = False
        site_packages_paths = site.getsitepackages()
        self.bin_dir = os.path.join(site_packages_paths[0], 'bin')
        self.lib_dirs = _dedup(site_packages_paths[0], site_packages_paths[1])


def get_distribution(param):
    pass


def get_site_packages_dir(prefix: str = "", suffix: str = "") -> str:
    dist = get_distribution("pip")
    return dist.location


def _get_system_sitepackages() -> Set[str]:
    system_sites = site.getsitepackages()
    return {os.path.normcase(path) for path in system_sites}


class BuildEnvironment:
    def __init__(self) -> None:
        temp_dir = get_site_packages_dir(prefix="build-env-", suffix="")

        self._prefixes = OrderedDict(
            (name, _Prefix(os.path.join(temp_dir, name)))
            for name in ("normal", "overlay")
        )

        self._bin_dirs = []
        self._lib_dirs = []
        for prefix in reversed(list(self._prefixes.values())):
            self._bin_dirs.append(prefix.bin_dir)
            self._lib_dirs.extend(prefix.lib_dirs)

        system_sites = _get_system_sitepackages()

        self._site_dir = os.path.join(temp_dir, "site")
        if not os.path.exists(self._site_dir):
            os.mkdir(self._site_dir)
        with open(
                os.path.join(self._site_dir, "sitecustomize.py"), "w", encoding="utf-8"
        ) as fp:
            fp.write(
                textwrap.dedent(
                    """
                    import os, site, sys

                    original_sys_path = sys.path[:]
                    known_paths = set()
                    for path in {system_sites!r}:
                        site.addsitedir(path, known_paths=known_paths)
                    sys.path[:] = [
                        path for path in sys.path
                        if os.path.normcase(path) not in known_paths
                    ] + original_sys_path

                    for path in {lib_dirs!r}:
                        assert not path in sys.path
                        site.addsitedir(path)
                    """
                ).format(system_sites=system_sites, lib_dirs=self._lib_dirs)
            )

    def __enter__(self) -> None:
        self._save_env = {
            name: os.environ.get(name, None)
            for name in ("PATH", "PYTHONNOUSERSITE", "PYTHONPATH")
        }

        path = self._bin_dirs[:]
        old_path = self._save_env["PATH"]
        if old_path:
            path.extend(old_path.split(os.pathsep))

        pythonpath = [self._site_dir]

        os.environ.update(
            {
                "PATH": os.pathsep.join(path),
                "PYTHONNOUSERSITE": "1",
                "PYTHONPATH": os.pathsep.join(pythonpath),
            }
        )

    def __exit__(
            self,
            exc_type: Optional[Type[BaseException]],
            exc_val: Optional[BaseException],
            exc_tb: Optional[TracebackType],
    ) -> None:
        for varname, old_value in self._save_env.items():
            if old_value is None:
                del os.environ[varname]
            else:
                os.environ[varname] = old_value

    # ... rest of the class ...
